<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

    <!-- Search Engine Optimization -->
    <!-- Begin Jekyll SEO tag v2.3.0 -->
<title>Solving with A* search | mazes</title>
<meta property="og:title" content="Solving with A* search" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A simple maze generator / solver based on graph theory. http://mazes.jabaridash.com" />
<meta property="og:description" content="A simple maze generator / solver based on graph theory. http://mazes.jabaridash.com" />
<link rel="canonical" href="http://localhost:4000/mazes/pages/aStar.html" />
<meta property="og:url" content="http://localhost:4000/mazes/pages/aStar.html" />
<meta property="og:site_name" content="mazes" />
<script type="application/ld+json">
{"name":null,"description":"A simple maze generator / solver based on graph theory. http://mazes.jabaridash.com","author":null,"@type":"WebPage","url":"http://localhost:4000/mazes/pages/aStar.html","publisher":null,"image":null,"headline":"Solving with A* search","dateModified":null,"datePublished":null,"sameAs":null,"mainEntityOfPage":null,"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/mazes/assets/css/style.css?v=5a9f46489db7909c50a81239f87e1833928f6fbb">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/mazes/assets/css/main.css">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="/mazes/assets/css/font-awesome.min.css">
  </head>

  <body>

    <!-- Page header -->
    <section class="page-header">

      <!-- Headings -->
      <h1 class="project-name">mazes</h1>
      <h2 class="project-tagline">A simple maze generator / solver based on graph theory. http://mazes.jabaridash.com</h2>
      
        <a href="http://github.com/N02870941/mazes" class="btn" target="_blank">View on GitHub</a>
      

      <!-- Download buttons -->
      
        <a href="http://github.com/N02870941/mazes/zipball/gh-pages" class="btn">Download .zip</a>
        <a href="http://github.com/N02870941/mazes/tarball/gh-pages" class="btn">Download .tar.gz</a>
      
    </section>

    <!-- Main page content -->
    <section class="main-content">

      <!-- Back button -->
      <!-- Back button (Don't show on homepage) -->

  <button onclick="goBack()">
    <i class='fa fa-arrow-left'></i> Back
  </button>

  <script>
  function goBack() {
      window.history.back();
  }
  </script>



      <!-- Main content -->
      <h1 id="solving-with-a-search">Solving with A* search</h1>
<p>The limitations of Dijkstra’s algorithm is the reason we use A* (A Star). A* is an <strong>informed search</strong> that uses a heuristic function to help guide our search.</p>

<h2 id="what-is-a-heuristic">What is a heuristic?</h2>
<p>The heuristic is an easy-to-compute value computed for each discovered vertex that we use to determine whether or not we are getting closer to our target. The equation follows.</p>

<p align="center">
  <img src="img/png/informed-search-equation.png" /><br />
</p>

<p>The function <code class="highlighter-rouge">g(n)</code> is the cost associated with getting to that vertex. <code class="highlighter-rouge">h(n)</code> is the estimate (heuristic) cost <strong>between</strong> that vertex and the target vertex. The sum <code class="highlighter-rouge">f(n)</code> is an overall <strong>estimated</strong> cost from start to finish if the current node is in the final solution. In other words:</p>

<p><em>“If we visit node</em> <code class="highlighter-rouge">n</code><em>, we anticipate the overall cost of the solution to be</em> <code class="highlighter-rouge">f(n)</code> <em>based on how far we have gone,</em><code class="highlighter-rouge">g(n)</code> <em>plus how far we think we have to go,</em><code class="highlighter-rouge">h(n)</code><em>.”</em></p>

<p>For this reason, when ordering nodes in the priority queue, we want to sort such that nodes that warrant smaller <code class="highlighter-rouge">f(n)</code> values have higher priority.</p>

<h2 id="restrictions-on-heuristics">Restrictions on heuristics</h2>
<p>The <code class="highlighter-rouge">h(n)</code> function is very useful in that it helps us rule out expanding too wide and taking too many intermediate steps that stray away from the target.</p>

<p>However, there are some restrictions on <code class="highlighter-rouge">h(n)</code>.</p>

<ol>
  <li>The unit should be the same as that <code class="highlighter-rouge">g(n)</code>.</li>
  <li>It <strong>should</strong> be admissible.</li>
</ol>

<p>If the unit of the heuristic function is not the same as the unit used by <code class="highlighter-rouge">g(n)</code>, then we are not approximating the <strong>cost</strong> - we are computing some other value. For example, for grids, sometimes the euclidian distance squared is used as the heuristic. If we are computing distance in centimeters, <code class="highlighter-rouge">g(n)</code> is in centimeters, and <code class="highlighter-rouge">h(n)</code> is in centimeters squared. We cannot add centimeters and centimeters squared. If we add just their magnitudes (ignoring units), provided that centimeters squared is an order of magnitude larger than centimeters, we will be imposing a <strong>huge</strong> bias on the heuristic over the aggregated cost <code class="highlighter-rouge">g(n)</code>. It turns out weighting the heuristic may be a good thing, but there are also some draw backs - most notabely that it breaks admissibility.</p>

<p>A heuristic function is <strong>admissible</strong> if it never overestimates. For the purpose of traversing a weighted graph using A*, this means the heuristic never returns an estimate path cost that exceeds the minimum cost path from the current node to the target. If it does, then the <code class="highlighter-rouge">f(n)</code> overestimates, gets assigned a lower priority in the priority queue, and potentially never gets explored if the target is found before it is dequeued. This will result in a sub-optimal solution because we have <strong>narrowed the search too much</strong>.</p>

<p>The advantage of a non-admissible heuristic is if there are not many obsticals A* will not stray off on to too many paths because it is making decisions almost entirely based on the heuristic. For a good heuristic, this means we will find a solution very quickly - often times in a small amount of steps. The disadvantage is that a heuristic that overestimates is effectively overlooking potentially better options - kind of like tunnel vision.</p>

<p>So, even though A* with a weighted heuristic will run very fast, if it is not admissible, it may not always return the optimal solution. For most applications this is okay, as it may be more valuable to find a solution that is slighlty sub-optimal extremely quickly than to do a near exhaustive search to find the exact optimal solution. There is math that says that we can pick a non-admissible heuristic that guarantees solutions with a cost that is some scalar multiple ε of the optimal solutions cost, where ε ≥ 1. Essentially we are “limiting the inefficiency” of the solution by some epsilon. This is called an ε-admissible heuristic. However, that is beyond the scope of this project.</p>

<h2 id="chosing-a-heuristic">Chosing a heuristic</h2>
<p>Deciding on a heuristic function is highly dependent on the nature of the problem. For example, for a grid where diagonal movement is allowed, the straight-line (euclidian) distance is a good choice.</p>

<p>However, for grids where only lateral movement is allowed euclidian almost always <strong>underestimates</strong> because we cannot actually ever go in a straight line. This is okay, as it will still lead to an optimal solution, but because it consistently underestimates, we will branch out very far and explore many more options than necessary. A better heuristic is manhattan distance.</p>

<p>Manhattan distance is essentially creating a triangle between two points and instead of taking the length of the hypotenuse (euclidian distance), we sum the lengths of the other two sides. It can also be seen as follows:</p>

<p><em>You are in the upper-west side of Manhattan and you would like to get to the lower-east side. You compute your distance to your target by counting the number of blocks downtown you must walk and summing that with the number of blocks crosstown you must walk.</em></p>

<p>This gives us a more accurate yet still admissible approximation. In fact, for our purpose, if our maze had no walls, the manhattan distance would be a perfect heuristic, meaning it always estimates the exact distance to the target every time, thus producing a search that finds the optimal solution on it’s first try and does not visit vertices that do not contribute to the final solution.</p>

<h2 id="implementing-a">Implementing A*</h2>
<p>The code for A* is nearly identical to that of Dijkstra’s algorithm. The only difference is the function used when assigning order in the priority queue.</p>

<p>Pseudo code follows:</p>

<h2 id="time-complexity-of-a">Time complexity of A*</h2>

<p>A* in the worst case degrades to Dijkstra’s algorithm. This occurs when the heuristic function severely underestimates on each iteration and never rules out any adjacent nodes to visit. In other words, if <code class="highlighter-rouge">h(n) = 0</code> for all nodes, A* is equivalent to Dijkstra’s algorithm. In that event, we visit all <code class="highlighter-rouge">|V|</code> vertices, each of which requires a <code class="highlighter-rouge">pop()</code> and up to 4 <code class="highlighter-rouge">push()</code>operations on the min heap - each of which is <code class="highlighter-rouge">O(log |V|)</code>. This results in <code class="highlighter-rouge">O(|V| * log |V|)</code> operations.</p>

<p><strong>Solving the maze with A* is done in</strong> <code class="highlighter-rouge">O(|V| * log |V|)</code> <strong>time.</strong></p>

<h2 id="space-complexity-of-a">Space complexity of A*</h2>

<p>A* uses a priority queue of unvisited vertices. In the worst case, we
push all <code class="highlighter-rouge">|V|</code> vertices before popping. This is the case where we visit <strong>all</strong> vertices in a single walk before hitting a dead end. The map used for backtracking in the worst case will hold references to all <code class="highlighter-rouge">|V|</code> vertices in the path from source to destination - also using at most <code class="highlighter-rouge">O(|V|)</code> space. Lastly, if we pre-compute our heuristics for easy lookup (one per vertex), we will need <code class="highlighter-rouge">O(|V|)</code> extra space - still resulting in linear space.</p>

<p><strong>The space complexity of A* is</strong> <code class="highlighter-rouge">O(|V|)</code>.</p>


      <!-- Site footer -->
      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="http://github.com/N02870941/mazes">mazes</a> is maintained by <a href="http://github.com/N02870941">N02870941</a>.</span>
        
      </footer>
    </section>

    <!-- Google Analytics -->
    
      <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'true', 'auto');
        ga('send', 'pageview');
      </script>
    

    <!-- JQuery -->
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

    <!-- Side navbar -->
    
<!--
  By default sidebar is hidden, that way,
  when we navigate to a page by the "Back()"
  event, the menu is not by default open.
 -->
<div id="sidebar" style="display:none;">

  <!--
    Invisiable checkbox, when checked,
    menu shows. This is accomplished at
    the CSS level using selectors
  -->
  <input type="checkbox" id="navigation" />
  <label for="navigation">
        <i class='fa fa-2x fa-bars'></i>
  </label>

  <!-- List of options -->
  <nav id="menu">
    <ul>
      <li><a name="/mazes/" onclick="navigate_to_page(this.name)">Home</a></li>
      <li><a name="/mazes/pages/install.html" onclick="navigate_to_page(this.name)">Installation Guide</a></li>
      <li><a name="/mazes/pages/backtrack.html" onclick="navigate_to_page(this.name)">Generating with backtracking</a></li>
      <li><a name="/mazes/pages/dfs.html" onclick="navigate_to_page(this.name)">Solving with DFS</a></li>
      <li><a name="/mazes/pages/bfs.html" onclick="navigate_to_page(this.name)">Solving with BFS</a></li>
      <li><a name="/mazes/pages/dijkstra.html" onclick="navigate_to_page(this.name)">Solving with Dijkstra's Algorithm</a></li>
      <li><a name="/mazes/pages/aStar.html" onclick="navigate_to_page(this.name)">Solving with A* search</a></li>
      <li><a name="/mazes/pages/performance.html" onclick="navigate_to_page(this.name)">Performance comparison</a></li>
    </ul>
  </nav>
</div>

<script>

  // Hides the navbar menu
  let closeMenu = function() {
    $('#navigation').prop('checked', false);

    // Resolve promise after 250ms, gives
    // enough time for close animation to complete
    return new Promise(resolve => setTimeout(resolve, 250));
  }

  // By default the sidebare is hidden.
  // Make sure we uncheck the nav checkbox
  // so the menu is not out, then we can
  // show the sidebar (make it clickable)
  $(document).ready(function() {
      closeMenu();
      $('#sidebar').show();
  });

  // Close menu on Escape press
  $(document).keyup(function(e) {
     if (e.keyCode == 27) {
        closeMenu();
    }
  });

  // Close menu if click happens
  // outside of the sidebar
  $(document).mouseup(function(e) {
    let sidebar = $("#sidebar");

    // if the target of the click isn't the container
    // nor a descendant of the container, close the menue
    if (!sidebar.is(e.target) && sidebar.has(e.target).length === 0) {
        closeMenu();
    }
  });

  // Closes menu, then navigates to the href
  let navigate_to_page = async function(href) {
    await closeMenu();

    document.location.href = href;
  }
</script>


    <!-- Back to top button -->
    <div class='scrolltop'>
  <div class='scroll icon'>
    <i class='fa fa-4x fa-angle-up'></i>
  </div>
</div>

<script>
(function() {
    $(window).scroll(function() {
      if ($(this).scrollTop() > 50) {
          $('.scrolltop:hidden').stop(true, true).fadeIn();
      } else {
          $('.scrolltop').stop(true, true).fadeOut();
      }
    });
    $('.scroll').click(function() {
  		$('html, body').animate({
        scrollTop : 0},800);
  		return false;
  	});
})();
</script>

  </body>
</html>
