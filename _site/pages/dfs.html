<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

    <!-- Search Engine Optimization -->
    <!-- Begin Jekyll SEO tag v2.3.0 -->
<title>Solving with Depth-first search (DFS) | mazes</title>
<meta property="og:title" content="Solving with Depth-first search (DFS)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A simple maze generator / solver based on graph theory. http://mazes.jabaridash.com" />
<meta property="og:description" content="A simple maze generator / solver based on graph theory. http://mazes.jabaridash.com" />
<link rel="canonical" href="http://localhost:4000/mazes/pages/dfs.html" />
<meta property="og:url" content="http://localhost:4000/mazes/pages/dfs.html" />
<meta property="og:site_name" content="mazes" />
<script type="application/ld+json">
{"name":null,"description":"A simple maze generator / solver based on graph theory. http://mazes.jabaridash.com","author":null,"@type":"WebPage","url":"http://localhost:4000/mazes/pages/dfs.html","publisher":null,"image":null,"headline":"Solving with Depth-first search (DFS)","dateModified":null,"datePublished":null,"sameAs":null,"mainEntityOfPage":null,"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/mazes/assets/css/style.css?v=5a9f46489db7909c50a81239f87e1833928f6fbb">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/mazes/assets/css/main.css">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="/mazes/assets/css/font-awesome.min.css">
  </head>

  <body>

    <!-- Page header -->
    <section class="page-header">

      <!-- Headings -->
      <h1 class="project-name">mazes</h1>
      <h2 class="project-tagline">A simple maze generator / solver based on graph theory. http://mazes.jabaridash.com</h2>
      
        <a href="http://github.com/N02870941/mazes" class="btn" target="_blank">View on GitHub</a>
      

      <!-- Download buttons -->
      
        <a href="http://github.com/N02870941/mazes/zipball/gh-pages" class="btn">Download .zip</a>
        <a href="http://github.com/N02870941/mazes/tarball/gh-pages" class="btn">Download .tar.gz</a>
      
    </section>

    <!-- Main page content -->
    <section class="main-content">

      <!-- Back button -->
      <!-- Back button (Don't show on homepage) -->

  <button onclick="goBack()">
    <i class='fa fa-arrow-left'></i> Back
  </button>

  <script>
  function goBack() {
      window.history.back();
  }
  </script>



      <!-- Main content -->
      <h1 id="solving-with-depth-first-search-dfs">Solving with Depth-first search (DFS)</h1>
<p>A modified depth-first search can be used, stopping once we come across the
target vertex. We then backtrack to reconstruct the path from source to destination. This is a brute force method that may not always result in the optimal solution if there is more than one path from beginning to end. However, in practice it runs relatively fast in comparison to other search algorithms.</p>

<h2 id="implementing-dfs">Implementing DFS</h2>
<p>To implement DFS we start by pushing the source vertex onto a stack of unvisited. We then loop until the unvisited node stack is empty. Within the loop, we <code class="highlighter-rouge">pop()</code> a node. If this node is the target, we break, otherwise we check if the node is unvisited. If so, we mark it as visited, then push all of it’s unvisited neighbors onto the stack.</p>

<p>Pseudo code follows:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">dfs</span><span class="p">(</span><span class="nx">src</span><span class="p">,</span> <span class="nx">dst</span><span class="p">)</span> <span class="p">{</span>

	<span class="kd">var</span> <span class="nx">unvisited</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">// Stack</span>
	<span class="kd">var</span> <span class="nx">neighbors</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">// Set</span>
	<span class="kd">var</span> <span class="nx">parents</span>   <span class="o">=</span> <span class="p">[]</span>  <span class="c1">// Map</span>
	<span class="kd">var</span> <span class="nx">current</span>

	<span class="c1">// The start vertex has no parent</span>
	<span class="nx">parents</span><span class="p">[</span><span class="nx">src</span><span class="p">.</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">null</span>

	<span class="c1">// Start with source</span>
	<span class="nx">unvisited</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">src</span><span class="p">);</span>

	<span class="c1">// Process each vertex</span>
	<span class="k">while</span> <span class="p">(</span><span class="nx">unvisited</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="c1">// Get next vertex</span>
		<span class="nx">current</span> <span class="o">=</span> <span class="nx">unvisited</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>

		<span class="c1">// We found the target</span>
		<span class="k">if</span> <span class="p">(</span><span class="nx">current</span> <span class="o">==</span> <span class="nx">dst</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">break</span>
		<span class="p">}</span>

		<span class="c1">// If first time visiting</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">current</span><span class="p">.</span><span class="nx">visited</span><span class="p">)</span> <span class="p">{</span>

			<span class="c1">// Label is visited</span>
			<span class="nx">current</span><span class="p">.</span><span class="nx">visited</span> <span class="o">=</span> <span class="kc">true</span>

			<span class="c1">// Get it's neighbors</span>
			<span class="nx">neighbors</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">neighbors</span><span class="p">()</span>

			<span class="c1">// Push all unvisited neighbors to stack</span>
			<span class="nx">neighbors</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span> <span class="nx">neighbor</span> <span class="o">=&gt;</span> <span class="p">{</span>

				<span class="c1">// If there is no path to this vertex yet</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">neighbor</span><span class="p">.</span><span class="nx">visited</span><span class="p">)</span> <span class="p">{</span>

					<span class="c1">// Create a mapping for backtracking</span>
					<span class="nx">parents</span><span class="p">[</span><span class="nx">neighbor</span><span class="p">.</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">key</span>

					<span class="c1">// Add to start for processing</span>
					<span class="nx">unvisited</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">)</span>
				<span class="p">}</span>

			<span class="p">})</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Start at destination</span>
	<span class="nx">current</span> <span class="o">=</span> <span class="nx">dst</span>

	<span class="c1">// Backtrack highlighting the path</span>
	<span class="k">while</span> <span class="p">(</span><span class="nx">current</span><span class="p">)</span> <span class="p">{</span>

		<span class="nx">current</span><span class="p">.</span><span class="nx">highlight</span><span class="p">()</span>

		<span class="nx">current</span> <span class="o">=</span> <span class="nx">parents</span><span class="p">[</span><span class="nx">current</span><span class="p">.</span><span class="nx">key</span><span class="p">]</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<h2 id="time-complexity-of-dfs">Time complexity of DFS</h2>
<p>Depth-first search visits all <code class="highlighter-rouge">|V|</code> vertices in the outer loop. Each loop iteration visits at most all of that vertex’s edges, which for a grid is always 4. Discovering adjacent vertices is done in <code class="highlighter-rouge">O(1)</code> time. The <code class="highlighter-rouge">push()</code> and <code class="highlighter-rouge">pop()</code> operation on the stack are also done in constant time. So, <code class="highlighter-rouge">O(|V| * 1)</code> results in linear time with respect to vertices.</p>

<p><strong>The runtime of DFS is</strong> <code class="highlighter-rouge">O(|V|)</code>.</p>

<h2 id="space-complexity-of-dfs">Space complexity of DFS</h2>

<p>This depth-first search uses a stack of unvisitd vertices. In the worst case, we
push all <code class="highlighter-rouge">|V|</code> vertices before popping. This is the case where we visit <strong>all</strong> vertices in a single walk before hitting a dead end. The map used for backtracking in the worst case will hold references to all <code class="highlighter-rouge">|V|</code> vertices in the path from source to destination - also using at most <code class="highlighter-rouge">O(|V|)</code> space.</p>

<p><strong>The space complexity of DFS is</strong> <code class="highlighter-rouge">O(|V|)</code>.</p>


      <!-- Site footer -->
      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="http://github.com/N02870941/mazes">mazes</a> is maintained by <a href="http://github.com/N02870941">N02870941</a>.</span>
        
      </footer>
    </section>

    <!-- Google Analytics -->
    
      <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'true', 'auto');
        ga('send', 'pageview');
      </script>
    

    <!-- JQuery -->
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

    <!-- Side navbar -->
    
<!--
  By default sidebar is hidden, that way,
  when we navigate to a page by the "Back()"
  event, the menu is not by default open.
 -->
<div id="sidebar" style="display:none;">

  <!--
    Invisiable checkbox, when checked,
    menu shows. This is accomplished at
    the CSS level using selectors
  -->
  <input type="checkbox" id="navigation" />
  <label for="navigation">
        <i class='fa fa-2x fa-bars'></i>
  </label>

  <!-- List of options -->
  <nav id="menu">
    <ul>
      <li><a name="/mazes/" onclick="navigate_to_page(this.name)">Home</a></li>
      <li><a name="/mazes/pages/install.html" onclick="navigate_to_page(this.name)">Installation Guide</a></li>
      <li><a name="/mazes/pages/backtrack.html" onclick="navigate_to_page(this.name)">Generating with backtracking</a></li>
      <li><a name="/mazes/pages/dfs.html" onclick="navigate_to_page(this.name)">Solving with DFS</a></li>
      <li><a name="/mazes/pages/bfs.html" onclick="navigate_to_page(this.name)">Solving with BFS</a></li>
      <li><a name="/mazes/pages/dijkstra.html" onclick="navigate_to_page(this.name)">Solving with Dijkstra's Algorithm</a></li>
      <li><a name="/mazes/pages/aStar.html" onclick="navigate_to_page(this.name)">Solving with A* search</a></li>
      <li><a name="/mazes/pages/performance.html" onclick="navigate_to_page(this.name)">Performance comparison</a></li>
    </ul>
  </nav>
</div>

<script>

  // Hides the navbar menu
  let closeMenu = function() {
    $('#navigation').prop('checked', false);

    // Resolve promise after 250ms, gives
    // enough time for close animation to complete
    return new Promise(resolve => setTimeout(resolve, 250));
  }

  // By default the sidebare is hidden.
  // Make sure we uncheck the nav checkbox
  // so the menu is not out, then we can
  // show the sidebar (make it clickable)
  $(document).ready(function() {
      closeMenu();
      $('#sidebar').show();
  });

  // Close menu on Escape press
  $(document).keyup(function(e) {
     if (e.keyCode == 27) {
        closeMenu();
    }
  });

  // Close menu if click happens
  // outside of the sidebar
  $(document).mouseup(function(e) {
    let sidebar = $("#sidebar");

    // if the target of the click isn't the container
    // nor a descendant of the container, close the menue
    if (!sidebar.is(e.target) && sidebar.has(e.target).length === 0) {
        closeMenu();
    }
  });

  // Closes menu, then navigates to the href
  let navigate_to_page = async function(href) {
    await closeMenu();

    document.location.href = href;
  }
</script>


    <!-- Back to top button -->
    <div class='scrolltop'>
  <div class='scroll icon'>
    <i class='fa fa-4x fa-angle-up'></i>
  </div>
</div>

<script>
(function() {
    $(window).scroll(function() {
      if ($(this).scrollTop() > 50) {
          $('.scrolltop:hidden').stop(true, true).fadeIn();
      } else {
          $('.scrolltop').stop(true, true).fadeOut();
      }
    });
    $('.scroll').click(function() {
  		$('html, body').animate({
        scrollTop : 0},800);
  		return false;
  	});
})();
</script>

  </body>
</html>
