<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

    <!-- Search Engine Optimization -->
    <!-- Begin Jekyll SEO tag v2.3.0 -->
<title>Performance comparison when solving (in practice) | mazes</title>
<meta property="og:title" content="Performance comparison when solving (in practice)" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/mazes/pages/performance.html" />
<meta property="og:url" content="http://localhost:4000/mazes/pages/performance.html" />
<meta property="og:site_name" content="mazes" />
<script type="application/ld+json">
{"name":null,"description":null,"author":null,"@type":"WebPage","url":"http://localhost:4000/mazes/pages/performance.html","publisher":null,"image":null,"headline":"Performance comparison when solving (in practice)","dateModified":null,"datePublished":null,"sameAs":null,"mainEntityOfPage":null,"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/mazes/assets/css/style.css?v=f2997125d230ad37bca04874497998b7759dde17">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/mazes/assets/css/main.css">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="/mazes/assets/css/font-awesome.min.css">
  </head>

  <body>

    <!-- Page header -->
    <section class="page-header">

      <!-- Headings -->
      <h1 class="project-name">mazes</h1>
      <h2 class="project-tagline"></h2>
      
        <a href="http://github.com/N02870941/mazes" class="btn" target="_blank">View on GitHub</a>
      

      <!-- Download buttons -->
      
        <a href="https://github.com/N02870941/rpi_cluster/archive/master.zip" class="btn">Download .zip</a>
        <a href="https://github.com/N02870941/rpi_cluster/archive/master.tar.gz" class="btn">Download .tar.gz</a>
      
    </section>

    <!-- Main page content -->
    <section class="main-content">

      <!-- Back button -->
      <!-- Back button (Don't show on homepage) -->

  <button onclick="goBack()">
    <i class='fa fa-arrow-left'></i> Back
  </button>

  <script>
  function goBack() {
      window.history.back();
  }
  </script>



      <!-- Main content -->
      <h1 id="performance-comparison-when-solving-in-practice">Performance comparison when solving (in practice)</h1>
<p>The asymptotic runtime of solving the maze is roughly the same for each solution. Generally speaking, it is <code class="highlighter-rouge">|V|</code> multiplied by the longer runtime between the <code class="highlighter-rouge">push()</code> and <code class="highlighter-rouge">pop()</code> operation for the specified data structure used to queue unvisited nodes.</p>

<p>For DFS and BFS we use a stack and a queue respectively, each of which performs <code class="highlighter-rouge">push()</code> and <code class="highlighter-rouge">pop()</code> in <code class="highlighter-rouge">O(1)</code> time - hence <code class="highlighter-rouge">O(|V|)</code> overall runtime. For A* and Dijkstra we use a priority queue that performs <code class="highlighter-rouge">push()</code> and <code class="highlighter-rouge">pop()</code> in <code class="highlighter-rouge">O(log |V|)</code> runtime - hence <code class="highlighter-rouge">O(|V| * log |V|)</code> overall runtime.</p>

<p>We are not going to prove the average case runtime because the math can get quite complex. However, we are going to look at <strong>runtime in practice</strong> to make some <strong>observations</strong> and potentially determine one of the methods as the best method for solving the <strong>mazes generated by this</strong> application.</p>

<p>We start with a 300 x 300 square maze.</p>

<p align="center">
  <img src="../assets/img//png/performance/maze.png" /><br />
  <i>A maze generated with BFS + backtracking.</i>
</p>

<p>Above is a 300 x 300 square maze with 40% of the vertical walls removed and 52% of the horizontal walls removed so that there are many paths from start to finish.  When searching for our target (from top left to bottom right) there are a total of 90,000 squares we can visit before exhausting our search. There is an optimal path length of about 599, although multiple optimal (and sub-optimal) solutions may exist.</p>

<p align="center">
  <img src="../assets/img//png/performance/
maze-solution-depth-first-search-5017-6574.png" /><br />
  <i>Maze solved with DFS.</i>
</p>

<p>Here we solve with depth-first search. It is a brute force approach where we go as deep as possible before turning around and trying new paths. It works, but it does not give us an optimal solution. Here we found the target by visiting 6574 squares with a path of length 5017. We visited 7% of the grid, but do not have am optimal solution or anything close.</p>

<p align="center">
  <img src="../assets/img//png/performance/maze-solution-breadth-first-search-599-89999.png" /><br />
  <i>Maze solved with BFS.</i>
</p>

<p>We can find the optimal path by using another brute force method, breadth-first search. Which is, expanding as wide as possible before turning around. This gives us the optimal solution of length 599 but we visited all 90000 squares to find it. Not efficient.</p>

<p align="center">
  <img src="../assets/img//png/performance/maze-solution-dijkstra-uniform-cost-search-599-89999.png" /><br />
  <i>Maze solved with Dijkstra's algorithm.</i>
</p>

<p>In theory, we could improve BFS by using Dijkstra’s algorithm, a uniform cost search algorithm that choses to visit adjacent neighbors with lower costs first. Unfortunately, for a maze, the cost to visit any neighbor is always exactly 1, so we are technically sorting 1’s every time. Dijkstra’s algorithm degrades to best-first search and acts nearly identically to breadth-first search. The only difference is sometimes the shape of the path because the ordering of nodes is slightly different. But, for a graph where all edges have the same cost, Dijkstra behaves like a brute force algorithm. Here we still visited all 90000 squares to compute an optimal path of length 599.</p>

<p align="center">
  <img src="../assets/img//png/performance/maze-solution-astar-euclidian-unweighted-599-84729.png" /><br />
  <i>Maze solved with A* using euclidian distance as the heuristic.</i>
</p>

<p>Another improvement to solving the maze is using the A* search using the euclidian distance as the heuristic. However, since the euclidian distance will often be a diagonal line, this heuristic consistantly underestimates because we <strong>cannot actually go diagonally</strong>. So, it only helps us eliminate the extreme corners and we still branch off pretty far. We visited 84729 out of 90000 (94% of all) squares - very inefficient.</p>

<p align="center">
  <img src="../assets/img//png/performance/maze-solution-astar-manhattan-unweighted-599-15764.png" /><br />
  <i>Maze solved with A* using manhattan distance as the heuristic.</i>
</p>

<p>An improvement to A* where only perpendicular movement is allowed is changing the heuristic to manhattan distance. That is, rather than computing the straight line distance, we imagine we are in the city of New York, trying to get to from the upper west side to the lower east side. We count the number of blocks downtown we must walk and then add that to the number of blocks east we must walk. This gives us a very close approximation as to how many squares we must visit. This produced a path of length 599 but we only visited 15764 squares - 17% of the maze.</p>

<p>However, we still notice that we are visiting many squares that do not contribute to the final result. The reason is because we have no mechanism for breaking ties between equally good options. For example, we see for this maze, many optimal solutions lie both above and below the straight line from the top-left corner to the bottom-right corner. If we are on a vertex that lies on the line, the vertices both above and to the right of our current position are equally good choices. We consider this a tie. Presently, we have no mechanism for breaking this tie so we explore both. We must add a tie-breaker.</p>

<p align="center">
  <img src="../assets/img//png/performance/maze-solution-astar-manhattan-weighted-599-2740.png" /><br />
  <i>Maze solved with A* using weighted manhattan distance as the heuristic.</i>
</p>

<p>Another improvement to A* is adding a weight to the heuristic, or a tie breaker. This allows us to impose a bias when we come across 2 equally weighted choices. This however, if it ever overestimates, will cause A* to output a slightly sub-optimal result. This breaks the admissible property of the heuristic. However, for most applications, this is okay if we are one or two steps off. The benefit is that depending on how much we weight the heuristic, we avoid straying off onto different paths.</p>

<p>For this particular application,  we consider a step in a particular direction a vector. We compute the determinant of that step vector and the vector from origin to target. We then use some multiple of this value to add to our heuristic (manhattan distance).</p>

<p>The reason we do this is because the determinant of any 2d vectors tells us information about the angle made between the two vectors. The closer these vectors are to parallel, the small that angle gets - eventually reaching 0 if the vectors are perfectly parallel.</p>

<p>So, if we are above the line, and we have an equal choice to go right (further from the line) or down (closer to the line), even though the cost of both steps is 1 (equal), we break this tie by choosing the vector that produces an angle “most parallel” to the straight line from origin to target, which in this case is down because we are rotating towards the line rather than away from it.</p>

<p>This approach produces the optimal solution of length 599 in 2740 total visits. This is about 3% of the total number of squares. This is a highly efficient approach, although sometimes producing slightly sub-optimal solutions depending on the admissibility of the heuristic.</p>

<h2 id="conclusion">Conclusion</h2>
<p>Clearly using A* with weighted manhattan distance is the fastest approach at finding a solution. If the maze had one solution, it may perform nearly identically to unweighted manhattan. But, we see the biggest pitfall of A* is tiebreaking. However, this can be easily overcome by slightly breaking admissibility. This is often the favored approach in real life.</p>

<p align="center"><i>Speed</i> &gt; <i>Optimality</i></p>


      <!-- Site footer -->
      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="http://github.com/N02870941/mazes">mazes</a> is maintained by <a href="http://github.com/N02870941">N02870941</a>.</span>
        
      </footer>
    </section>

    <!-- Google Analytics -->
    
      <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'true', 'auto');
        ga('send', 'pageview');
      </script>
    

    <!-- JQuery -->
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

    <!-- Side navbar -->
    
<!--
  By default sidebar is hidden, that way,
  when we navigate to a page by the "Back()"
  event, the menu is not by default open.
 -->
<div id="sidebar" style="display:none;">

  <!--
    Invisiable checkbox, when checked,
    menu shows. This is accomplished at
    the CSS level using selectors
  -->
  <input type="checkbox" id="navigation" />
  <label for="navigation">
        <i class='fa fa-2x fa-bars'></i>
  </label>

  <!-- List of options -->
  <nav id="menu">
    <ul>
      <li><a name="/mazes/" onclick="navigate_to_page(this.name)">Home</a></li>
      <li><a name="/mazes/pages/install.html" onclick="navigate_to_page(this.name)">Installation Guide</a></li>
      <li><a name="/mazes/pages/backtrack.html" onclick="navigate_to_page(this.name)">Generating with backtracking</a></li>
      <li><a name="/mazes/pages/dfs.html" onclick="navigate_to_page(this.name)">Solving with DFS</a></li>
      <li><a name="/mazes/pages/bfs.html" onclick="navigate_to_page(this.name)">Solving with BFS</a></li>
      <li><a name="/mazes/pages/dijkstra.html" onclick="navigate_to_page(this.name)">Solving with Dijkstra's Algorithm</a></li>
      <li><a name="/mazes/pages/aStar.html" onclick="navigate_to_page(this.name)">Solving with A* search</a></li>
      <li><a name="/mazes/pages/performance.html" onclick="navigate_to_page(this.name)">Performance comparison</a></li>
    </ul>
  </nav>
</div>

<script>

  // Hides the navbar menu
  let closeMenu = function() {
    $('#navigation').prop('checked', false);

    // Resolve promise after 250ms, gives
    // enough time for close animation to complete
    return new Promise(resolve => setTimeout(resolve, 250));
  }

  // By default the sidebare is hidden.
  // Make sure we uncheck the nav checkbox
  // so the menu is not out, then we can
  // show the sidebar (make it clickable)
  $(document).ready(function() {
      closeMenu();
      $('#sidebar').show();
  });

  // Close menu on Escape press
  $(document).keyup(function(e) {
     if (e.keyCode == 27) {
        closeMenu();
    }
  });

  // Close menu if click happens
  // outside of the sidebar
  $(document).mouseup(function(e) {
    let sidebar = $("#sidebar");

    // if the target of the click isn't the container
    // nor a descendant of the container, close the menue
    if (!sidebar.is(e.target) && sidebar.has(e.target).length === 0) {
        closeMenu();
    }
  });

  // Closes menu, then navigates to the href
  let navigate_to_page = async function(href) {
    await closeMenu();

    document.location.href = href;
  }
</script>


    <!-- Back to top button -->
    <div class='scrolltop'>
  <div class='scroll icon'>
    <i class='fa fa-4x fa-angle-up'></i>
  </div>
</div>

<script>
(function() {
    $(window).scroll(function() {
      if ($(this).scrollTop() > 50) {
          $('.scrolltop:hidden').stop(true, true).fadeIn();
      } else {
          $('.scrolltop').stop(true, true).fadeOut();
      }
    });
    $('.scroll').click(function() {
  		$('html, body').animate({
        scrollTop : 0},800);
  		return false;
  	});
})();
</script>

  </body>
</html>
