<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

    <!-- Search Engine Optimization -->
    <!-- Begin Jekyll SEO tag v2.3.0 -->
<title>Intuition | mazes</title>
<meta property="og:title" content="Intuition" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/mazes/" />
<meta property="og:url" content="http://localhost:4000/mazes/" />
<meta property="og:site_name" content="mazes" />
<script type="application/ld+json">
{"name":"mazes","description":null,"author":null,"@type":"WebSite","url":"http://localhost:4000/mazes/","publisher":null,"image":null,"headline":"Intuition","dateModified":null,"datePublished":null,"sameAs":null,"mainEntityOfPage":null,"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/mazes/assets/css/style.css?v=f2997125d230ad37bca04874497998b7759dde17">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/mazes/assets/css/main.css">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="/mazes/assets/css/font-awesome.min.css">
  </head>

  <body>

    <!-- Page header -->
    <section class="page-header">

      <!-- Headings -->
      <h1 class="project-name">mazes</h1>
      <h2 class="project-tagline"></h2>
      
        <a href="http://github.com/N02870941/mazes" class="btn" target="_blank">View on GitHub</a>
      

      <!-- Download buttons -->
      
        <a href="https://github.com/N02870941/rpi_cluster/archive/master.zip" class="btn">Download .zip</a>
        <a href="https://github.com/N02870941/rpi_cluster/archive/master.tar.gz" class="btn">Download .tar.gz</a>
      
    </section>

    <!-- Main page content -->
    <section class="main-content">

      <!-- Back button -->
      <!-- Back button (Don't show on homepage) -->



      <!-- Main content -->
      <h1 id="intuition">Intuition</h1>
<p>One way of framing the problem of generating and solving a maze is in terms of graph theory. For the
purpose of clarity, we will use the words maze and graph interchangeably. If you
are not familiar with graph theory, here is an explanation of the information
about graph theory that is relevant to understand this problem.</p>

<p>A graph <code class="highlighter-rouge">G</code> is a pair denoted as <code class="highlighter-rouge">G = {V, E}</code> where <code class="highlighter-rouge">V</code> is a set of vertices and
<code class="highlighter-rouge">E</code> is a set of edges where each edge connects some vertex <code class="highlighter-rouge">u</code> to some vertex <code class="highlighter-rouge">v</code> from the vertex set <code class="highlighter-rouge">V</code>. A vertex is an abstract
<strong>node or location</strong> in a network. An edge is a <strong>branch</strong> that links vertices together. Graphs
come in various forms:</p>

<ol>
  <li>Weighted</li>
  <li>Directed</li>
</ol>

<p>Any combination is valid:</p>

<ol>
  <li>Weighted and directed</li>
  <li>Weighted and undirected</li>
  <li>Unweighted and directed</li>
  <li>Unweighted and undirected</li>
</ol>

<p align="center">
  <img src="assets/img/png/weighted-unweighted.png" /><br />
</p>

<p>A weighted graph is a graph who’s edges have a specified <strong>weight</strong> or <strong>cost</strong> associated
with branching two vertices. For example, if we represent a country as a graph where
cities are vertices and roads are edges, the weight of an edge might be the distance between
two cities.</p>

<p align="center">
  <img src="assets/img/png/directed-undirected.png" /><br />
</p>

<p>A directed graph is a graph where an edge <code class="highlighter-rouge">e</code>  from vertex <code class="highlighter-rouge">u</code> to
<code class="highlighter-rouge">v</code> is not equal to an edge <code class="highlighter-rouge">f</code> from <code class="highlighter-rouge">v</code> to <code class="highlighter-rouge">u</code>. In other words, edges are directional. For example, in our graph that represents a country we may have an edge (road) from New York to Chicago with weight 200 miles.
But, we have a <strong>different</strong> edge going from Chicago to New York that is 250 miles because the return route may require taking a different road.</p>

<p align="center">
  <img src="assets/img/png/undirected-weighted.png" /><br />
  <i>Undirected, weighted graph with uniform costs that represents a 2 x 2 pixel image.</i>
</p>

<p>For the purpose of representing a maze, we will use an undirected weighted graph.
We will consider vertices white pixel (areas). A vertex is considered adjacent or having an edge with another vertex if there is <strong>no</strong> barrier (black pixels) between them. Edges will have a uniform weight of 1 which
just indicates that two vertices are one pixel away from each other (adjacent).</p>

<p align="center">
  <img src="assets/img/png/grid.png" /><br />
  <i>A 30 x 30 square grid that represents a graph with <strong>no</strong> edges.</i>
</p>

<h1 id="maze-generating">Maze generating</h1>
<p>Generating a maze requires a modified graph traversal algorithm. Traversing the graph means to
<strong>visit</strong> each node from a specified starting vertex. If an undirected graph is
<strong>connected</strong> then there exists a path from each vertex to every other vertex in the graph.</p>

<p align="center">
  <img src="assets/img/png/unweighted-undirected-graph.png" /><br />
  <i>A connected unweighted graph.</i>
</p>

<p>In the case of a <strong>blank</strong> <code class="highlighter-rouge">n x n</code> image where <code class="highlighter-rouge">n</code> is the width (and height) of the image
in pixels, the image <strong>always</strong> represents connected graph. The reason is that
there are no missing pixels / black lines. So, in terms of
traversing the image, there exist a path from each white pixel to every other white pixel - this is too many
in fact.</p>

<p>This is why we have black lines to represent the <strong>absence</strong> of edges, or a boundary that terminates a particular path. But, in the case of our full grid, we have too many boundaries as well - resulting in zero paths.</p>

<p>Our goal is to traverse our image full of boundaries and <strong>remove</strong> (recreate) as many (paths) as possible but still produce a graph that has the connected property. This will result in a maze that leaves a
<strong>path</strong> from any vertex to any other vertex, but in a much less cluttered way.
The result is called a <strong>spanning tree</strong>.</p>

<p align="center">
  <img src="assets/img/png/spanning-tree.png" /><br />
  <i>A spanning tree of the above graph.</i>
</p>

<p>A spanning tree <code class="highlighter-rouge">S</code> is a sub-graph of a graph <code class="highlighter-rouge">G = {V, E}</code> that contains the minimum
number of edges required to connect all vertices in <code class="highlighter-rouge">G</code>. If we denote the number of
vertices in <code class="highlighter-rouge">G</code> as <code class="highlighter-rouge">|V|</code> and number of edges as <code class="highlighter-rouge">|E|</code>, then for graph <code class="highlighter-rouge">S</code>, <code class="highlighter-rouge">|V'| = |V|</code> and <code class="highlighter-rouge">|E'| = |V| - 1</code>. It also turns out that graph <code class="highlighter-rouge">S</code> has the <strong>acyclic</strong> property of a graph.</p>

<p align="center">
  <img src="assets/img/png/cyclic-acyclic.png" /><br />
  <i>A cyclic graph, and it's acyclic sub-graph.</i>
</p>

<p>A graph is acyclic if there is <strong>no way</strong> to start
at a specified vertex <code class="highlighter-rouge">vi</code> and follow an alternating sequence of vertices and edges <code class="highlighter-rouge">v1, e1, v2, e2...</code>
where edge <code class="highlighter-rouge">ei</code> connects <code class="highlighter-rouge">vi</code> and <code class="highlighter-rouge">vi+1</code> and visit the same vertex twice. In other words, there
are no loops or repitition in a walk of the graph.</p>

<p>As we traverse the graph removing walls, we will
be generating a continuous path of white pixels that represent traversable vertices
in the graph. Black pixels that are left over will be the walls of the maze. They
are the absence of edges, or area that does not allow us to go from one vertex to another.</p>

<p align="center">
  <img src="assets/img/png/maze.png" /><br />
  <i>Our result once the correct amount of walls is removed will look like this.</i>
</p>

<p>Now that we have framed the problem, we can see some of the algorithms used to actually generate the mazes.</p>

<h1 id="notes-on-runtime-and-space-analysis">Notes on runtime and space analysis</h1>

<p>We will explore the runtime of both generating the maze, and solving it. But, before we do that
we must prove a few things and understand that runtime analysis on graphs is often times
dependent on <strong>how</strong> the graph is implemented. Let’s explore the worst case scenarios.</p>

<p>As stated, a graph <code class="highlighter-rouge">G = {V, E}</code> can have a vertex set with cardinality <code class="highlighter-rouge">|V|</code>. Provided
that each vertex in an <strong>arbitrary</strong> graph can be connected to at most, every other vertex, the cardinality of the edge set
<code class="highlighter-rouge">E</code> can be expressed as <code class="highlighter-rouge">|E| ≈ |V|²</code>. <strong>However, for this particular problem, we can assert otherwise</strong>.</p>

<p>The reason is because we are working on an image where edges only exist between <strong>adjacent</strong> pixels. A pixel can only be adjacent to at most 4 other vertices.
Consider a grid composed of <code class="highlighter-rouge">|V|</code> vertices.</p>

<p>A vertex has at most 4 adjacent vertices:</p>

<ol>
  <li>Top</li>
  <li>Bottom</li>
  <li>Left</li>
  <li>Right</li>
</ol>

<p>We can also visualize each vertex from <code class="highlighter-rouge">(0,0)</code> to <code class="highlighter-rouge">(k,k)</code> where <code class="highlighter-rouge">k = n - 1</code> as follows:</p>

<p align="center">
  <img src="assets/img/png/branching-factor.png" />
</p>

<p>We observe, that each vertex has 4 edges that point to the top, bottom, left, and right
adjacent vertices. In total, for <code class="highlighter-rouge">|V|</code> vertices we have 4 * <code class="highlighter-rouge">|V|</code> edges. <code class="highlighter-rouge">|E|</code> is linear with respect to <code class="highlighter-rouge">|V|</code>.
Although typically we say <code class="highlighter-rouge">O(|E|) = O(|V|²)</code>, for <strong>this particular problem</strong> we can say <code class="highlighter-rouge">O(|E|) = O(|V|) = O(n²)</code> where <code class="highlighter-rouge">n</code> is the number of boxes in our grid.</p>

<h1 id="implementation-details">Implementation details</h1>
<p>There are many ways to represent a graph in memory. The typical implementations of the graph structure are Edge List, Adjacency Matrix, and Adjacency List. However, since this graph does not need to support all of the standard graph operations, we will implement a modified version of the adjacency list. We will have a single array called <code class="highlighter-rouge">grid</code> that represents a flattened <code class="highlighter-rouge">n x n</code> matrix of squares / vertices. The <code class="highlighter-rouge">grid</code> array will be of type <code class="highlighter-rouge">Cell</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Cell {

	walls     = 1111
	visited   = false
	cost      = Infinity
	heuristic = 0
}
</code></pre></div></div>

<p>Each <code class="highlighter-rouge">Cell</code> object contains a 4-bit binary string containing boolean values indicating whether or not any of the 4 walls are present for that <code class="highlighter-rouge">Cell</code>. If a particular bit is set to 0, then there is <strong>no</strong> wall, or there <strong>is</strong> and edge between that cell and the cell indicated by the position of the bit. If the bit is set to 1, a wall <strong>does</strong> exist or there is <strong>not</strong> an edge to the adjacent vertex. The bit mapping goes as follows:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Bit</th>
      <th style="text-align: center">Neighbor</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td style="text-align: center">top</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">right</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">bottom</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">left</td>
    </tr>
  </tbody>
</table>

<p>For example, if <code class="highlighter-rouge">wall = 1010</code>, then the cell has a top, and bottom wall, but it does not have a left or right wall. In order to actually check the value of or modify on of the flags, we must use bitwise operations.</p>

<p>In regards to edge weight, there is no need to actually store that information. As noted, all edges have a weight of 1 because the distance between two adjacent pixels is always 1. So, we can simply ignore it. Instead, we just give each cell a <code class="highlighter-rouge">cost</code> field that represents the <strong>aggregated weight</strong> associated with <strong>getting to</strong> that vertex from a specified start vertex.</p>

<p align="center">
  <img src="assets/img/png/uniform-costs.png" /><br />
  <i>A walk from vertex A to I on a weighted graph.</i>
</p>

<p>For a given walk of the graph, the cost of a vertex <code class="highlighter-rouge">v_i</code> is always the cost of vertex <code class="highlighter-rouge">v_(i-1) + 1</code>, where <code class="highlighter-rouge">v_(i-1)</code> is the vertex just before vertex <code class="highlighter-rouge">v_i</code> in the walk. So, when we traverse the graph, we just keep incrementing as we go instead of wasting space on information we can confidently predict and compute when it is needed. We see for vertices that we have not discovered or visited, by default their cost is infinite - this will come in handy when finding the shortest path between two vertices.</p>


      <!-- Site footer -->
      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="http://github.com/N02870941/mazes">mazes</a> is maintained by <a href="http://github.com/N02870941">N02870941</a>.</span>
        
      </footer>
    </section>

    <!-- Google Analytics -->
    
      <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'true', 'auto');
        ga('send', 'pageview');
      </script>
    

    <!-- JQuery -->
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

    <!-- Side navbar -->
    
<!--
  By default sidebar is hidden, that way,
  when we navigate to a page by the "Back()"
  event, the menu is not by default open.
 -->
<div id="sidebar" style="display:none;">

  <!--
    Invisiable checkbox, when checked,
    menu shows. This is accomplished at
    the CSS level using selectors
  -->
  <input type="checkbox" id="navigation" />
  <label for="navigation">
        <i class='fa fa-2x fa-bars'></i>
  </label>

  <!-- List of options -->
  <nav id="menu">
    <ul>
      <li><a name="/mazes/" onclick="navigate_to_page(this.name)">Home</a></li>
      <li><a name="/mazes/pages/install.html" onclick="navigate_to_page(this.name)">Installation Guide</a></li>
      <li><a name="/mazes/pages/backtrack.html" onclick="navigate_to_page(this.name)">Generating with backtracking</a></li>
      <li><a name="/mazes/pages/dfs.html" onclick="navigate_to_page(this.name)">Solving with DFS</a></li>
      <li><a name="/mazes/pages/bfs.html" onclick="navigate_to_page(this.name)">Solving with BFS</a></li>
      <li><a name="/mazes/pages/dijkstra.html" onclick="navigate_to_page(this.name)">Solving with Dijkstra's Algorithm</a></li>
      <li><a name="/mazes/pages/aStar.html" onclick="navigate_to_page(this.name)">Solving with A* search</a></li>
      <li><a name="/mazes/pages/performance.html" onclick="navigate_to_page(this.name)">Performance comparison</a></li>
    </ul>
  </nav>
</div>

<script>

  // Hides the navbar menu
  let closeMenu = function() {
    $('#navigation').prop('checked', false);

    // Resolve promise after 250ms, gives
    // enough time for close animation to complete
    return new Promise(resolve => setTimeout(resolve, 250));
  }

  // By default the sidebare is hidden.
  // Make sure we uncheck the nav checkbox
  // so the menu is not out, then we can
  // show the sidebar (make it clickable)
  $(document).ready(function() {
      closeMenu();
      $('#sidebar').show();
  });

  // Close menu on Escape press
  $(document).keyup(function(e) {
     if (e.keyCode == 27) {
        closeMenu();
    }
  });

  // Close menu if click happens
  // outside of the sidebar
  $(document).mouseup(function(e) {
    let sidebar = $("#sidebar");

    // if the target of the click isn't the container
    // nor a descendant of the container, close the menue
    if (!sidebar.is(e.target) && sidebar.has(e.target).length === 0) {
        closeMenu();
    }
  });

  // Closes menu, then navigates to the href
  let navigate_to_page = async function(href) {
    await closeMenu();

    document.location.href = href;
  }
</script>


    <!-- Back to top button -->
    <div class='scrolltop'>
  <div class='scroll icon'>
    <i class='fa fa-4x fa-angle-up'></i>
  </div>
</div>

<script>
(function() {
    $(window).scroll(function() {
      if ($(this).scrollTop() > 50) {
          $('.scrolltop:hidden').stop(true, true).fadeIn();
      } else {
          $('.scrolltop').stop(true, true).fadeOut();
      }
    });
    $('.scroll').click(function() {
  		$('html, body').animate({
        scrollTop : 0},800);
  		return false;
  	});
})();
</script>

  </body>
</html>
